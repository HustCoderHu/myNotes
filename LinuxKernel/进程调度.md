
---

# 1 多任务
多任务系统分两类
- 非抢占式
- 抢占式

# 2 调度策略
为达到这些互相冲突的目标 进程响应时间尽可能快，后台作业的吞吐量尽可能高，尽可能避免进程的饥饿，低优先级和高优先级进程尽可能调和。  
策略的权衡就显得很重要。
上面这些目标会影响不同类型的进程  
- IO密集型
- CPU密集型

或者另一种分法
- 交互式进程
  > 和用户交互, 花很多时间等等键盘和鼠标操作。典型有shell，文本编辑程序和图像应用程序
- 批处理进程
  > 交互少，典型有编译程序，数据库搜索引擎以及科学计算
- 实时进程
  > 要求响应时间短，响应时间变化小，典型有视频和音频程序，机器人控制程序，物理传感器信息收集程序

Linux按照下面的进程类型调度
- SCHED_FIFO
  > 先进先出的实时进程，如果没有其他可运行的更高优先级实时进程，就霸占运行队列链表当前位置，持续使用CPU
- SCHED_RR
  > 时间片轮转的实时进程。抢到CPU时，进程描述符被放在运行队列(runqueue)链表末尾。保证所有相同优先级的 SCHED_RR 进程公平分配CPU时间
- SCHED_NORMAL
  > 普通的分时进程

## 进程优先级
时间片的分法会参考下面几个值来进行
### nice 值
范围 -20 ~ +19, 默认 0，越大优先级越低，可以理解为对其他进程更“优待”。它是所有Unix系统的标准化概念。不同系统的用法不同  
`ps -el` 命令可以看到 NI 字段
``` sh
$ ps -el
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0   681     1  0  80   0 -  6051 ep_pol ?        00:00:00 systemd-logind
4 S    81   682     1  0  80   0 -  6136 ep_pol ?        00:00:00 dbus-daemon
4 S     0   694     1  0  80   0 -  6464 hrtime ?        00:00:00 atd
4 S     0   695     1  0  80   0 - 31558 hrtime ?        00:00:00 crond
4 S     0   707     1  0  80   0 - 27511 n_tty_ tty1     00:00:00 agetty
4 S     0   864     1  0  80   0 - 140598 poll_s ?       00:00:01 tuned
4 S     0   865     1  0  80   0 - 26499 poll_s ?        00:00:00 sshd
0 S     0  1045     1  0  80   0 - 28813 do_wai ?        00:00:00 sh
4 S     0 31125 31120  0  80   0 - 28881 do_wai pts/0    00:00:00 bash
0 R     0 31156 31125  0  80   0 - 37235 -      pts/0    00:00:00 ps
```

### 静态优先级
普通进程使用，范围 100(高) ~ 139(低)，和nice值一样的优先规律。本质上决定了进程的基本时间片

### 动态优先级
调度程序在选择新进程运行时使用，经验公式为  
`max(100, min(静态优先级 - bonus + 5, 139) )` bonus 处于 [0, 10]，依赖进程过去的情况，与平均睡眠时间相关

### 实时优先级
实时进程使用 范围 [1, 99], 基于时间片轮转的实时进程基本时间片还是依赖静态优先级  

# Linux 调度算法
调度器类是模块化结构，不同类型的进程可以有针对性的选择调度算法。
## 传统 Unix 调度算法
进程启动就有默认时间片。算法存在几个问题
### 1 nice 值对应 CPU 绝对时间
因为要将 nice 值映射到时间片

完全公平调度 CFS 是针对普通进程的调度类。

# schedule() 函数
实现调度程序。它会从运行队列的链表里找到一个进程，并随后将cpu分配给这个进程。可由几个内核控制路径调用，可以直接调用或者延迟调用。

## 直接调用
- 1 将 current 进程插入适当的等待队列
- 2 把 current 进程状态改为 `TASK_INTERRUPTIBLE` 或 `TASK_UNINTERRUPTIBLE`
- 3 调用 schedule()
- 4 检查资源是否可用，不可用就转到 2
- 5 资源可用，就从等待队列删除 current

# reference
Linux内核设计与实现 第三版  
深入理解Linux内核 第三版  