linux x64 分页

---

# 线性地址 逻辑地址 虚拟地址
以代码段为例 intel 32位(64bit long mode 下 分段被禁用，内存完全平坦)
## 段式内存管理
逻辑地址(logical address) 表示 selector:offset
- selector: cs 寄存器的值
- offset: EIP 值

linear address = segment base address(段基址) + offset(段内偏移)  
段基址 = GDT(全局描述符表).selector

## 页式内存管理
接上面把 linear addr 切 4段(对应下面的3级分页模型)

## 虚拟地址
EIP 寄存器的值，或者等同于逻辑地址的offset

## Linux 设定
内核将所有段基址设成0，段限长到最大值(涉及段描述符结构，理解成地址总线最大寻址限度)，导致所有段重合，即不分段，  
于是虚拟地址和逻辑地址值就相等了

# 4 级分页模型
linux采用了一种同时适用于 32 位和 64位系统的普通分页模型
- 页全局目录 page global directory  = 9 bit
- 页上级目录 upper  = 9 bit
- 页中间目录 middle  = 9 bit
- 页表 page table  = 9 bit

![](https://images0.cnblogs.com/blog2015/624196/201508/162118543952835.png)

高16位符号扩展，没有使用。普通页大小仍为 4K，然而数据却占64位，所以4K页在x64下只能包含 4K/64b = 512 项内容，  
为了保证页对齐和以页为单位的页表内容换入换出，在x64下每级页表寻址部分长度定位9位

- 2 级页表
  > 没有启动物理地址扩展的 32 位系统, upper 和 middle 全 0
- 3 级
  > 启用扩展的32位系统，取消 upper
- x64
  > 3 级还是4级取决于硬件对线性地址的位划分

## 最大物理地址
在Intel中使用 `MAXPHYADDR` 来表示最大的物理地址，我们可以通过CPUID的指令来获得处理支持的最大物理地址，然而这已经不在此次的讨论范围之内，我们需要知道的只是：

- MAXPHYADDR 为36位
  > 在Intel平台的桌面处理器上普遍实现了36位的最高物理地址值，也就是我们普通的个人计算机，可寻址64G空间；
- MAXPHYADDR 为40位
  > 在Inter的服务器产品和AMD 的平台上普遍实现40位的最高物理地址，可寻址达1TB；
- MAXPHYADDR为52位
  > 这是x64体系结构描述最高实现值，目前尚未有处理器实现。

当MAXPHYADDR为36位时，上一级table entry的12~35位提供下一级table物理基地址的高24位，此时36~51是保留位，必须置0，低12位补零，达到基地址在4K边界对齐

# 进程页表
x86
- 0x0 到 0xbfff ffff 的线性地址，无论进程中用户态还是内核态都可以寻址
- 0xc000 0000 ~ 0xffffffff

x64

地址 | 空间
-|-
0x0 ~ 0x0000,7ffff,ffff,ffff = 128TB | 用户空间
0xffff,8000,0000,0000 ~ 全F = 128TB  | 系统空间

# reference
Linux 线性地址，逻辑地址和虚拟地址的关系？  
<https://www.zhihu.com/question/29918252>  
Linux x86_64与i386区别之 —— 内存寻址  
<https://blog.csdn.net/yunsongice/article/details/5821734>  
x64 结构体系下的内存寻址  
<http://www.cnblogs.com/lanrenxinxin/p/4735027.html>  